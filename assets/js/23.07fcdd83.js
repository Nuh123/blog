(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{369:function(t,a,r){"use strict";r.r(a);var e=r(42),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"v-for和v-if的优先级问题"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#v-for和v-if的优先级问题"}},[t._v("#")]),t._v(" v-for和v-if的优先级问题")]),t._v(" "),r("p",[t._v("结论：for 的优先级高于if 这是编译层面的问题，源码里有写（渲染器 => 代码编译），官方文档风格指南部分也有写。浪费性能。")]),t._v(" "),r("ol",[r("li",[t._v("这种写法无非就是两个目的，渲染一个if判断是否显示的列表，这样if提到外面一层即可，就是"),r("code",[t._v("多包一层")]),t._v("。")]),t._v(" "),r("li",[t._v("另外就是希望对列表项做一个筛选，这个其实可以在数据层面就筛一遍，完全没必要在视图层面处理。对应的解决方案很多，可以单纯地filter完数组再去v-for，也可以用vue的过滤器，最优解应该是使用计算属性（惰性触发）。")])]),t._v(" "),r("h1",{attrs:{id:"组件中data选项为啥一定是函数"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#组件中data选项为啥一定是函数"}},[t._v("#")]),t._v(" 组件中data选项为啥一定是函数")]),t._v(" "),r("p",[t._v("结论：组件会复用，闭包（函数作用域）防止污染（具体防污染的处理上有待斟酌）。，根实例没有这个限制，不复用，是单例。（主要还是innitstate数据时的事情）")]),t._v(" "),r("h1",{attrs:{id:"key的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#key的作用"}},[t._v("#")]),t._v(" key的作用")]),t._v(" "),r("p",[t._v("结论： 优化diff时的效率，识别一些旧的资源，在可复用时直接复用。")])])}),[],!1,null,null,null);a.default=v.exports}}]);